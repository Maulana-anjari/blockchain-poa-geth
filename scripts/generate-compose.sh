#!/bin/bash
# File: scripts/generate-compose.sh
# Generates Docker Compose files for PoA or PoS networks.
# This file is auto-generated by ./scripts/generate-compose.sh
# Do not edit it manually, as your changes will be overwritten.

set -e
source ./scripts/logger.sh
source ./config.sh

# --- Output File Definitions ---
POA_OUTPUT_FILE="docker-compose.poa.yml"
POS_OUTPUT_FILE="docker-compose.pos.yml"

# --- Reusable Service Snippets ---
generate_monitoring_stack() {
    local output_file=$1
    cat >> "$output_file" <<EOF

# --- Monitoring Stack ---
  ethstats-server:
    # Builds the Ethstats server image directly from its GitHub repository.
    build:
      context: https://github.com/goerli/ethstats-server.git
    container_name: ethstats-server
    environment:
      WS_SECRET: "\${ETHSTATS_WS_SECRET}"
    ports:
      - "\${BASE_MONITORING_HTTP_PORT}:3000"
    networks:
      - geth-network
    restart: unless-stopped

  influxdb:
    image: influxdb:1.8
    container_name: influxdb
    volumes:
      # Use a named volume for persistent metrics data.
      - influxdb_data:/var/lib/influxdb
    environment:
      INFLUXDB_DB: "\${INFLUXDB_DB}"
      INFLUXDB_ADMIN_USER: "\${INFLUXDB_USER}"
      INFLUXDB_ADMIN_PASSWORD: "\${INFLUXDB_PASSWORD}"
      INFLUXDB_HTTP_AUTH_ENABLED: "true"
      # These credentials are used by Geth to write data.
      INFLUXDB_USER: "\${INFLUXDB_USER}"
      INFLUXDB_USER_PASSWORD: "\${INFLUXDB_PASSWORD}"
    networks:
      - geth-network
    restart: unless-stopped

  grafana:
    image: grafana/grafana-oss:latest
    container_name: grafana
    depends_on: [influxdb]
    volumes:
      # Use a named volume for persistent dashboard configurations.
      - grafana_data:/var/lib/grafana
    ports:
      - "\${BASE_GRAFANA_HTTP_PORT}:3000"
    environment:
      GF_SECURITY_ADMIN_USER: admin
      GF_SECURITY_ADMIN_PASSWORD: "\${GRAFANA_ADMIN_PASSWORD}"
    networks:
      - geth-network
    restart: unless-stopped
  
  prometheus:
    image: prom/prometheus:latest
    container_name: prometheus
    volumes:
      - ./monitoring/prometheus.yml:/etc/prometheus/prometheus.yml
    ports:
      - "9090:9090"
    networks:
      - geth-network
    restart: unless-stopped

  pushgateway:
    image: prom/pushgateway:latest
    container_name: pushgateway
    ports:
      - "9091:9091"
    networks:
      - geth-network
    restart: unless-stopped
EOF
}

generate_footer() {
    local output_file=$1
    cat >> "$output_file" <<EOF

# --- Network & Volume Definitions ---
networks:
  geth-network:
    name: \${COMPOSE_PROJECT_NAME}_net
    driver: bridge

volumes:
  grafana_data: {}
  influxdb_data: {}
EOF
}

# --- PoA Network Generation ---
generate_poa_compose() {
    log_action "Generating services for PoA network"
    cat > "$POA_OUTPUT_FILE" <<EOF
# Auto-generated by scripts/generate-compose.sh for a PoA network.
services:
EOF
    # --- Bootnode (Non-Signer 1) ---
    cat >> "$POA_OUTPUT_FILE" <<EOF
  # --- Bootnode (Non-Signer 1) ---
  nonsigner1:
    image: ${GETH_IMAGE_TAG_POA}
    container_name: nonsigner1
    hostname: nonsigner1
    volumes:
      - ./config/genesis.json:/config/genesis.json:ro
      - ./data/nonsigner1:/root/.ethereum
      - ./config/passwords/nonsigner1.pass:/root/password.txt:ro
      - ./data/nonsigner1/keystore:/root/.ethereum/keystore:ro
    ports:
      - "\${BASE_GETH_P2P_PORT}:${BASE_GETH_P2P_PORT}/tcp"
      - "\${BASE_GETH_P2P_PORT}:${BASE_GETH_P2P_PORT}/udp"
      - "\${BASE_GETH_HTTP_PORT}:8545"
      - "\${BASE_GETH_WS_PORT}:8546"
    command: >
      geth
      --nodekey /root/.ethereum/geth/nodekey
      --datadir /root/.ethereum --keystore /root/.ethereum/keystore
      --networkid "\${NETWORK_ID}" --syncmode full --gcmode archive
      --port \${BASE_GETH_P2P_PORT}
      --http --http.addr "0.0.0.0" --http.port 8545 --http.api "eth,net,web3,clique,admin,personal" --http.corsdomain "*" --http.vhosts "*"
      --ws --ws.addr "0.0.0.0" --ws.port 8546 --ws.api "eth,net,web3,clique,admin,personal" --ws.origins "*"
      --metrics --metrics.expensive --metrics.influxdb
      --metrics.influxdb.endpoint "http://influxdb:8086"
      --metrics.influxdb.database "\${INFLUXDB_DB}"
      --metrics.influxdb.username "\${INFLUXDB_USER}"
      --metrics.influxdb.password "\${INFLUXDB_PASSWORD}"
      --ethstats "nonsigner1:\${ETHSTATS_WS_SECRET}@ethstats-server:3000"
      --password /root/password.txt --allow-insecure-unlock
    networks:
      - geth-network
    restart: unless-stopped
EOF
    # --- Signer Nodes (Clef + Geth) ---
    for i in $(seq 1 $NUM_SIGNERS); do
        HTTP_PORT=$((BASE_GETH_HTTP_PORT + (i * 2) + 10))
        WS_PORT=$((HTTP_PORT + 1))
        P2P_PORT=$((BASE_GETH_P2P_PORT + i))
        cat >> "$POA_OUTPUT_FILE" <<EOF

  # --- Signer Node ${i} ---
  clef${i}:
    build:
      context: .
      dockerfile: Dockerfile.clef
    container_name: clef${i}
    environment:
      - CLEF_MASTER_PASSWORD=${SIGNER_PASS_PREFIX}${i}
      - NETWORK_ID=${NETWORK_ID}
    volumes:
      - ./data/signer${i}/keystore:/root/.ethereum/keystore:ro
      - ./data/clef${i}:/root/.clef
      - ./config/rules.js:/root/rules.js:ro
    command: /usr/local/bin/start-clef.sh
    networks:
      - geth-network
    restart: unless-stopped

  signer${i}:
    image: ${GETH_IMAGE_TAG_POA}
    container_name: signer${i}
    depends_on:
      clef${i}:
        condition: service_started
      nonsigner1:
        condition: service_started
    volumes:
      - ./config/genesis.json:/config/genesis.json:ro
      - ./data/signer${i}:/root/.ethereum
    ports:
      - "${HTTP_PORT}:8545"
      - "${WS_PORT}:8546"
    command: >
      geth 
        --datadir /root/.ethereum 
        --networkid ${NETWORK_ID} 
        --syncmode full 
        --port ${P2P_PORT} 
        --http --http.addr "0.0.0.0" --http.port 8545 --http.api "eth,net,web3,clique,admin" --http.corsdomain "*" --http.vhosts "*" 
        --ws --ws.addr "0.0.0.0" --ws.port 8546 --ws.api "eth,net,web3,clique,admin" --ws.origins "*" 
        --metrics --metrics.expensive --metrics.influxdb 
        --metrics.influxdb.endpoint "http://influxdb:8086" 
        --metrics.influxdb.database "\${INFLUXDB_DB}" 
        --metrics.influxdb.username "\${INFLUXDB_USER}" 
        --metrics.influxdb.password "\${INFLUXDB_PASSWORD}" 
        --ethstats "signer${i}:\${ETHSTATS_WS_SECRET}@ethstats-server:3000" 
        --bootnodes "\${BOOTNODE_ENODE}" 
        --signer "http://clef${i}:8550" 
        --mine --miner.etherbase "\${SIGNER${i}_ADDRESS}"
    networks:
      - geth-network
    restart: unless-stopped
EOF
    done
    # --- Other Non-Signer Nodes ---
    if [ $NUM_NONSIGNERS -gt 1 ]; then
        for i in $(seq 2 $NUM_NONSIGNERS); do
            HTTP_PORT=$((BASE_GETH_HTTP_PORT + (NUM_SIGNERS * 2) + (i * 2) + 20))
            WS_PORT=$((HTTP_PORT + 1))
            P2P_PORT=$((BASE_GETH_P2P_PORT + NUM_SIGNERS + i))
            cat >> "$POA_OUTPUT_FILE" <<EOF

  # --- Non-Signer Node ${i} ---
  nonsigner${i}:
    image: ${GETH_IMAGE_TAG_POA}
    container_name: nonsigner${i}
    depends_on:
      - nonsigner1
    volumes:
      - ./config/genesis.json:/config/genesis.json:ro
      - ./data/nonsigner${i}:/root/.ethereum
      - ./config/passwords/nonsigner${i}.pass:/root/password.txt:ro
    ports:
      - "${HTTP_PORT}:8545"
      - "${WS_PORT}:8546"
    command: >
      geth
      --datadir /root/.ethereum --keystore /root/.ethereum/keystore --networkid "\${NETWORK_ID}"
      --syncmode full --gcmode archive --port ${P2P_PORT}
      --http --http.addr "0.0.0.0" --http.port 8545 --http.api "eth,net,web3,clique,admin,personal" --http.corsdomain "*" --http.vhosts "*"
      --ws --ws.addr "0.0.0.0" --ws.port 8546 --ws.api "eth,net,web3,clique,admin,personal" --ws.origins "*"
      --metrics --metrics.expensive --metrics.influxdb
      --metrics.influxdb.endpoint "http://influxdb:8086"
      --metrics.influxdb.database "\${INFLUXDB_DB}"
      --metrics.influxdb.username "\${INFLUXDB_USER}"
      --metrics.influxdb.password "\${INFLUXDB_PASSWORD}"
      --ethstats "nonsigner${i}:\${ETHSTATS_WS_SECRET}@ethstats-server:3000"
      --password /root/password.txt --allow-insecure-unlock
      --bootnodes "\${BOOTNODE_ENODE}"
    networks:
      - geth-network
    restart: unless-stopped
EOF
        done
    fi
    generate_monitoring_stack "$POA_OUTPUT_FILE"
    generate_footer "$POA_OUTPUT_FILE"
    log_success "Finished generating docker-compose.poa.yml."
}

# --- PoS Network Generation ---
generate_pos_compose() {
    log_action "Generating services for PoS network"
    cat > "$POS_OUTPUT_FILE" <<EOF
# Auto-generated by scripts/generate-compose.sh for a PoS network.
services:
  # --- Consensus Layer Bootnode (Prysm) ---
  consensus-bootnode:
    image: ${CONSENSUS_CLIENT_IMAGE}
    container_name: consensus-bootnode
    command: >
      --datadir=/consensus/beacondata
      --chain-config-file=/config/config.yml
      --genesis-state=/config/genesis.ssz
      --p2p-host-ip=0.0.0.0
      --p2p-tcp-port=13000
      --p2p-udp-port=12000
    volumes:
      - ./data/pos/consensus/beacondata:/consensus/beacondata
      - ./config/pos:/config
    networks:
      - geth-network
    restart: unless-stopped
EOF
    # --- Validator & RPC Nodes ---
    TOTAL_NODES=$((NUM_VALIDATORS + NUM_NON_VALIDATORS))
    for i in $(seq 1 $TOTAL_NODES); do
        # --- Execution Client (Geth) ---
        cat >> "$POS_OUTPUT_FILE" <<EOF
  execution${i}:
    image: ${GETH_IMAGE_TAG_POS}
    container_name: execution${i}
    command: >
      --datadir=/execution/geth
      --networkid=\${NETWORK_ID}
      --http --http.addr=0.0.0.0 --http.vhosts="*" --http.corsdomain="*"
      --http.api=eth,net,web3,engine
      --ws --ws.addr=0.0.0.0 --ws.origins="*"
      --authrpc.vhosts="*" --authrpc.addr=0.0.0.0 --authrpc.jwtsecret=/execution/jwt.hex
      --bootnodes="" # PoS uses CL for discovery
    volumes:
      - ./data/pos/execution/geth:/execution/geth
      - ./data/pos/jwtsecret/jwt.hex:/execution/jwt.hex
      - ./config/genesis.json:/config/genesis.json
    networks:
      - geth-network
    restart: unless-stopped
EOF
        # --- Consensus Client (Prysm Beacon) ---
        cat >> "$POS_OUTPUT_FILE" <<EOF
  consensus${i}:
    image: ${CONSENSUS_CLIENT_IMAGE}
    container_name: consensus${i}
    depends_on: [execution${i}]
    command: >
      --datadir=/consensus/beacondata
      --chain-config-file=/config/config.yml
      --genesis-state=/config/genesis.ssz
      --execution-endpoint=http://execution${i}:8551
      --jwt-secret=/consensus/jwt.hex
      --rpc-host=0.0.0.0
      --grpc-gateway-host=0.0.0.0
      --bootstrap-node=\$(/usr/local/bin/prysm.sh beacon-chain --datadir=/consensus/beacondata --chain-config-file=/config/config.yml --genesis-state=/config/genesis.ssz p2p id | grep "Peer ID" | awk '{print $3}')@consensus-bootnode:13000
    volumes:
      - ./data/pos/consensus/beacondata:/consensus/beacondata
      - ./config/pos:/config
      - ./data/pos/jwtsecret/jwt.hex:/consensus/jwt.hex
    networks:
      - geth-network
    restart: unless-stopped
EOF
        # --- Validator Client (Prysm Validator) ---
        if [ "$i" -le "$NUM_VALIDATORS" ]; then
            cat >> "$POS_OUTPUT_FILE" <<EOF
  validator${i}:
    image: ${CONSENSUS_CLIENT_VALIDATOR_IMAGE}
    container_name: validator${i}
    depends_on: [consensus${i}]
    command: >
      --datadir=/validator/data
      --beacon-rpc-provider=consensus${i}:4000
      --chain-config-file=/config/config.yml
      --wallet-dir=/validator/keys
      --wallet-password-file=/validator/pass/pass.txt
    volumes:
      - ./data/pos/consensus/validatordata/validator${i}:/validator/keys
      - ./data/pos/consensus/validatordata/pass.txt:/validator/pass/pass.txt
      - ./config/pos:/config
    networks:
      - geth-network
    restart: unless-stopped
EOF
        fi
    done
    generate_monitoring_stack "$POS_OUTPUT_FILE"
    generate_footer "$POS_OUTPUT_FILE"
    log_success "Finished generating docker-compose.pos.yml."
}

# --- Main Execution Logic ---
log_step "COMPOSE FILE GENERATION for NETWORK_TYPE: $NETWORK_TYPE"

if [ "$NETWORK_TYPE" == "PoA" ]; then
    generate_poa_compose
elif [ "$NETWORK_TYPE" == "PoS" ]; then
    generate_pos_compose
else
    log_error "Invalid NETWORK_TYPE '$NETWORK_TYPE' in .env file."
fi