#!/bin/bash
# File: scripts/generate-compose.sh
# Generates Docker Compose files for PoA or PoS networks.
# This file is auto-generated by ./scripts/generate-compose.sh
# Do not edit it manually, as your changes will be overwritten.

set -e
source ./scripts/logger.sh
source ./config.sh

# --- Output File Definitions ---
POA_OUTPUT_FILE="docker-compose.poa.yml"
POS_OUTPUT_FILE="docker-compose.pos.yml"

# --- Reusable Service Snippets ---
generate_monitoring_stack() {
    local output_file=$1
    cat >> "$output_file" <<EOF

# --- Monitoring Stack ---
  ethstats-server:
    # Builds the Ethstats server image directly from its GitHub repository.
    build:
      context: https://github.com/goerli/ethstats-server.git
    container_name: ethstats-server
    environment:
      WS_SECRET: "\${ETHSTATS_WS_SECRET}"
    ports:
      - "\${BASE_MONITORING_HTTP_PORT}:3000"
    networks:
      - skripsidchain
    restart: unless-stopped

  influxdb:
    image: influxdb:1.8
    container_name: influxdb
    volumes:
      # Use a named volume for persistent metrics data.
      - influxdb_data:/var/lib/influxdb
    environment:
      INFLUXDB_DB: "\${INFLUXDB_DB}"
      INFLUXDB_ADMIN_USER: "\${INFLUXDB_USER}"
      INFLUXDB_ADMIN_PASSWORD: "\${INFLUXDB_PASSWORD}"
      INFLUXDB_HTTP_AUTH_ENABLED: "true"
      # These credentials are used by Geth to write data.
      INFLUXDB_USER: "\${INFLUXDB_USER}"
      INFLUXDB_USER_PASSWORD: "\${INFLUXDB_PASSWORD}"
    networks:
      - skripsidchain
    restart: unless-stopped

  grafana:
    image: grafana/grafana-oss:latest
    container_name: grafana
    depends_on: [influxdb]
    volumes:
      # Use a named volume for persistent dashboard configurations.
      - grafana_data:/var/lib/grafana
    ports:
      - "\${BASE_GRAFANA_HTTP_PORT}:3000"
    environment:
      GF_SECURITY_ADMIN_USER: admin
      GF_SECURITY_ADMIN_PASSWORD: "\${GRAFANA_ADMIN_PASSWORD}"
    networks:
      - skripsidchain
    restart: unless-stopped
  
  prometheus:
    image: prom/prometheus:latest
    container_name: prometheus
    volumes:
      - ./monitoring/prometheus.yml:/etc/prometheus/prometheus.yml
    ports:
      - "9090:9090"
    networks:
      - skripsidchain
    restart: unless-stopped

  pushgateway:
    image: prom/pushgateway:latest
    container_name: pushgateway
    ports:
      - "9091:9091"
    networks:
      - skripsidchain
    restart: unless-stopped
EOF
}

generate_footer() {
    local output_file=$1
    cat >> "$output_file" <<EOF

# --- Network & Volume Definitions ---
networks:
  skripsidchain:
    name: \${COMPOSE_PROJECT_NAME}_net
    driver: bridge

volumes:
  grafana_data: {}
  influxdb_data: {}
EOF
}

# --- PoA Network Generation ---
generate_poa_compose() {
    log_action "Generating services for PoA network"
    cat > "$POA_OUTPUT_FILE" <<EOF
# Auto-generated by scripts/generate-compose.sh for a PoA network.
services:
EOF
    # --- Bootnode (Non-Signer 1) ---
    cat >> "$POA_OUTPUT_FILE" <<EOF
  # --- Bootnode (Non-Signer 1) ---
  nonsigner1:
    image: ${GETH_IMAGE_TAG_POA}
    container_name: nonsigner1
    hostname: nonsigner1
    volumes:
      - ./config/genesis.json:/config/genesis.json:ro
      - ./data/nonsigner1:/root/.ethereum
      - ./config/passwords/nonsigner1.pass:/root/password.txt:ro
      - ./data/nonsigner1/keystore:/root/.ethereum/keystore:ro
    ports:
      - "\${BASE_GETH_P2P_PORT}:${BASE_GETH_P2P_PORT}/tcp"
      - "\${BASE_GETH_P2P_PORT}:${BASE_GETH_P2P_PORT}/udp"
      - "\${BASE_GETH_HTTP_PORT}:8545"
      - "\${BASE_GETH_WS_PORT}:8546"
    command: >
      geth
      --nodekey /root/.ethereum/geth/nodekey
      --datadir /root/.ethereum --keystore /root/.ethereum/keystore
      --networkid "\${NETWORK_ID}" --syncmode full --gcmode archive
      --port \${BASE_GETH_P2P_PORT}
      --http --http.addr "0.0.0.0" --http.port 8545 --http.api "eth,net,web3,clique,admin,personal" --http.corsdomain "*" --http.vhosts "*"
      --ws --ws.addr "0.0.0.0" --ws.port 8546 --ws.api "eth,net,web3,clique,admin,personal" --ws.origins "*"
      --metrics --metrics.expensive --metrics.influxdb
      --metrics.influxdb.endpoint "http://influxdb:8086"
      --metrics.influxdb.database "\${INFLUXDB_DB}"
      --metrics.influxdb.username "\${INFLUXDB_USER}"
      --metrics.influxdb.password "\${INFLUXDB_PASSWORD}"
      --ethstats "nonsigner1:\${ETHSTATS_WS_SECRET}@ethstats-server:3000"
      --password /root/password.txt --allow-insecure-unlock
    networks:
      - skripsidchain
    restart: unless-stopped
EOF
    # --- Signer Nodes (Clef + Geth) ---
    for i in $(seq 1 $NUM_SIGNERS); do
        HTTP_PORT=$((BASE_GETH_HTTP_PORT + (i * 2) + 10))
        WS_PORT=$((HTTP_PORT + 1))
        P2P_PORT=$((BASE_GETH_P2P_PORT + i))
        cat >> "$POA_OUTPUT_FILE" <<EOF

  # --- Signer Node ${i} ---
  clef${i}:
    build:
      context: .
      dockerfile: Dockerfile.clef
    container_name: clef${i}
    hostname: clef${i}
    environment:
      - CLEF_MASTER_PASSWORD=${SIGNER_PASS_PREFIX}${i}
      - NETWORK_ID=${NETWORK_ID}
    volumes:
      - ./data/signer${i}/keystore:/root/.ethereum/keystore:ro
      - ./data/clef${i}:/root/.clef
      - ./config/rules.js:/root/rules.js:ro
    command: /usr/local/bin/start-clef.sh
    networks:
      - skripsidchain
    restart: unless-stopped

  signer${i}:
    image: ${GETH_IMAGE_TAG_POA}
    container_name: signer${i}
    hostname: signer${i}
    depends_on:
      clef${i}:
        condition: service_started
      nonsigner1:
        condition: service_started
    volumes:
      - ./config/genesis.json:/config/genesis.json:ro
      - ./data/signer${i}:/root/.ethereum
    ports:
      - "${HTTP_PORT}:8545"
      - "${WS_PORT}:8546"
    command: >
      geth 
        --datadir /root/.ethereum 
        --networkid ${NETWORK_ID} 
        --syncmode full 
        --port ${P2P_PORT} 
        --http --http.addr "0.0.0.0" --http.port 8545 --http.api "eth,net,web3,clique,admin" --http.corsdomain "*" --http.vhosts "*" 
        --ws --ws.addr "0.0.0.0" --ws.port 8546 --ws.api "eth,net,web3,clique,admin" --ws.origins "*" 
        --metrics --metrics.expensive --metrics.influxdb 
        --metrics.influxdb.endpoint "http://influxdb:8086" 
        --metrics.influxdb.database "\${INFLUXDB_DB}" 
        --metrics.influxdb.username "\${INFLUXDB_USER}" 
        --metrics.influxdb.password "\${INFLUXDB_PASSWORD}" 
        --ethstats "signer${i}:\${ETHSTATS_WS_SECRET}@ethstats-server:3000" 
        --bootnodes "\${BOOTNODE_ENODE}" 
        --signer "http://clef${i}:8550" 
        --mine --miner.etherbase "\${SIGNER${i}_ADDRESS}"
    networks:
      - skripsidchain
    restart: unless-stopped
EOF
    done
    # --- Other Non-Signer Nodes ---
    if [ $NUM_NONSIGNERS -gt 1 ]; then
        for i in $(seq 2 $NUM_NONSIGNERS); do
            HTTP_PORT=$((BASE_GETH_HTTP_PORT + (NUM_SIGNERS * 2) + (i * 2) + 20))
            WS_PORT=$((HTTP_PORT + 1))
            P2P_PORT=$((BASE_GETH_P2P_PORT + NUM_SIGNERS + i))
            cat >> "$POA_OUTPUT_FILE" <<EOF

  # --- Non-Signer Node ${i} ---
  nonsigner${i}:
    image: ${GETH_IMAGE_TAG_POA}
    container_name: nonsigner${i}
    hostname: nonsigner${i}
    depends_on:
      - nonsigner1
    volumes:
      - ./config/genesis.json:/config/genesis.json:ro
      - ./data/nonsigner${i}:/root/.ethereum
      - ./config/passwords/nonsigner${i}.pass:/root/password.txt:ro
    ports:
      - "${HTTP_PORT}:8545"
      - "${WS_PORT}:8546"
    command: >
      geth
      --datadir /root/.ethereum --keystore /root/.ethereum/keystore --networkid "\${NETWORK_ID}"
      --syncmode full --gcmode archive --port ${P2P_PORT}
      --http --http.addr "0.0.0.0" --http.port 8545 --http.api "eth,net,web3,clique,admin,personal" --http.corsdomain "*" --http.vhosts "*"
      --ws --ws.addr "0.0.0.0" --ws.port 8546 --ws.api "eth,net,web3,clique,admin,personal" --ws.origins "*"
      --metrics --metrics.expensive --metrics.influxdb
      --metrics.influxdb.endpoint "http://influxdb:8086"
      --metrics.influxdb.database "\${INFLUXDB_DB}"
      --metrics.influxdb.username "\${INFLUXDB_USER}"
      --metrics.influxdb.password "\${INFLUXDB_PASSWORD}"
      --ethstats "nonsigner${i}:\${ETHSTATS_WS_SECRET}@ethstats-server:3000"
      --password /root/password.txt --allow-insecure-unlock
      --bootnodes "\${BOOTNODE_ENODE}"
    networks:
      - skripsidchain
    restart: unless-stopped
EOF
        done
    fi
    generate_monitoring_stack "$POA_OUTPUT_FILE"
    generate_footer "$POA_OUTPUT_FILE"
    log_success "Finished generating docker-compose.poa.yml."
}
generate_pos_compose() {
    local compose_file="docker-compose.pos.yml"
    rm -f $compose_file
    log_info "Generating $compose_file for $POS_VALIDATOR_COUNT validators and $POS_NON_VALIDATOR_COUNT non-validators..."

    local total_nodes=$((POS_VALIDATOR_COUNT + POS_NON_VALIDATOR_COUNT))
    local data_dir_pos="./data/pos"

    # Start docker-compose file
    echo "services:" > $compose_file
    log_info "Retrieving Consensus Layer bootnode ENR from node1..."
    local bootnode_cl_enr=$BOOTSTRAP_CL_ENR

    log_info "Retrieving Execution Layer bootnode ENR from node1..."
    local bootnode_el_enode=$(docker run --rm -v $(pwd)/$data_dir_pos/node1/execution/geth:/geth $GETH_IMAGE_TAG_POS bootnode -genkey /geth/nodekey -writeaddress)
    local bootnode_el_pubkey=$(docker run --rm -v $(pwd)/$data_dir_pos/node1/execution/geth:/geth $GETH_IMAGE_TAG_POS bootnode --nodekey=/geth/nodekey -writeaddress)
    local bootnode_el_url="enode://$bootnode_el_pubkey@execution_node1:30303"

    # Add node services
    for i in $(seq 1 $total_nodes); do
        local is_validator=false
        if [ $i -le $POS_VALIDATOR_COUNT ]; then
            is_validator=true
        fi

        local el_http_port=$((8545 + i - 1))
        local el_ws_port=$((8645 + i - 1))
        local el_authrpc_port=$((8745 + i - 1))
        local el_metrics_port=$((8945 + i - 1))

        local el_p2p_port=$((30303 + i - 1))
        local cl_p2p_port=$((13000 + i - 1))
        local cl_grpc_port=$((4000 + i - 1))
        local cl_gateway_port=$((4100 + i - 1))
        local val_grpc_port=$((7500 + i - 1))

        # Execution Client (Geth)
        cat >> "$POS_OUTPUT_FILE" <<EOF
  execution_node$i:
    image: $GETH_IMAGE_TAG_POS
    container_name: execution_node$i
    hostname: execution_node$i
    command: >
      geth
      --nodekey=/root/.ethereum/geth/nodekey
      --datadir=/root/.ethereum
      --keystore=/root/.ethereum/keystore
      --networkid="\${NETWORK_ID}"
      --http
      --http.addr="0.0.0.0"
      --http.api="admin,debug,engine,eth,miner,net,rpc,txpool,web3"
      --http.corsdomain="*"
      --http.port=8545
      --http.vhosts="*"
      --ws
      --ws.api="eth,net,web3,engine,admin"
      --ws.addr="0.0.0.0"
      --ws.port=8645
      --ws.origins="*"
      --authrpc.vhosts="*"
      --authrpc.addr="0.0.0.0"
      --authrpc.port=8551
      --authrpc.jwtsecret=/config/jwt.hex
      --bootnodes="$bootnode_el_url"
      --port=$el_p2p_port
      --allow-insecure-unlock
      --unlock=\$NODE${i}_ADDRESS
      --password=/root/password.txt
      --syncmode=full
      --metrics
      --metrics.addr=execution_node$i
      --metrics.port=6060
      --metrics.expensive
      --metrics.influxdb
      --metrics.influxdb.endpoint="http://influxdb:8086"
      --metrics.influxdb.database="\${INFLUXDB_DB}"
      --metrics.influxdb.username="\${INFLUXDB_USER}"
      --metrics.influxdb.password="\${INFLUXDB_PASSWORD}"
      --ethstats="execution_node$i:\${ETHSTATS_WS_SECRET}@ethstats-server:3000"
    volumes:
      - $data_dir_pos/node$i/execution:/root/.ethereum
      - $data_dir_pos/node$i/execution/geth:/root/.ethereum/geth
      - $data_dir_pos/node$i/execution/keystore:/root/.ethereum/keystore:ro
      - $data_dir_pos/jwt.hex:/config/jwt.hex
      - $data_dir_pos/password.pass:/root/password.txt:ro
    ports:
      - "$el_http_port:8545"
      - "$el_ws_port:8645"
      - "$el_metrics_port:6060"
      - "$el_authrpc_port:8551"
      - "$el_p2p_port:$el_p2p_port"
      - "$el_p2p_port:$el_p2p_port/udp"
    networks:
      - skripsidchain
    restart: unless-stopped
EOF

        # Consensus Client (Prysm Beacon)
        # Build peer list for CL
        local cl_peers_param=""
        if [ $i -gt 1 ]; then
            # Get the peer ID of the first node to use as a reliable peer
            peer_id_node1=$(docker run --rm -v $(pwd)/$data_dir_pos/node1/consensus:/data $CONSENSUS_CLIENT_IMAGE --datadir=/data print-peer-id 2>/dev/null | grep "Peer ID" | awk '{print $NF}')
            if [ -n "$peer_id_node1" ]; then
                cl_peers_param="--peer=/ip4/consensus_node1/tcp/13000/p2p/$peer_id_node1"
            fi
        fi

        cat >> "$POS_OUTPUT_FILE" <<EOF
  consensus_node$i:
    image: $CONSENSUS_CLIENT_IMAGE
    container_name: consensus_node$i
    hostname: consensus_node$i
    command: >
      --datadir=/root/.ethereum
      --chain-config-file=/config/config.yml
      --genesis-state=/config/genesis.ssz
      --bootstrap-node="$bootnode_cl_enr"
      $cl_peers_param
      --interop-eth1data-votes
      --min-sync-peers=0
      --p2p-static-id=true
      --contract-deployment-block=0
      --chain-id=\${NETWORK_ID:-477748}
      --execution-endpoint=http://execution_node$i:8551
      --suggested-fee-recipient="\$NODE${i}_ADDRESS"
      --enable-debug-rpc-endpoints
      --minimum-peers-per-subnet=0
      --jwt-secret=/config/jwt.hex
      --accept-terms-of-use
      --rpc-host="0.0.0.0"
      --grpc-gateway-host="0.0.0.0"
      --p2p-tcp-port=$cl_p2p_port
      --p2p-udp-port=$cl_p2p_port
      --rpc-port=4000
      --grpc-gateway-port=$((cl_grpc_port + 100))
    volumes:
      - $data_dir_pos/node$i/consensus:/root/.ethereum
      - $data_dir_pos/config.yml:/config/config.yml
      - $data_dir_pos/genesis.ssz:/config/genesis.ssz
      - $data_dir_pos/jwt.hex:/config/jwt.hex
    ports:
      - "$cl_p2p_port:$cl_p2p_port"
      - "$cl_p2p_port:$cl_p2p_port/udp"
      - "$cl_grpc_port:4000"
      - "$((cl_grpc_port + 100)):$((cl_grpc_port + 100))"
    depends_on:
      execution_node$i:
        condition: service_started
    networks:
      - skripsidchain
    restart: unless-stopped
EOF

        # Validator Client (Prysm Validator) - only for validators
        if $is_validator; then
        local val_start_index=$(((i - 1) * 64))
        cat >> "$POS_OUTPUT_FILE" <<EOF
  validator_node$i:
    image: $CONSENSUS_CLIENT_VALIDATOR_IMAGE
    container_name: validator_node$i
    hostname: validator_node$i
    command: >
      --datadir=/root/.ethereum
      --beacon-rpc-provider=consensus_node$i:4000
      --chain-config-file=/config/config.yml
      --accept-terms-of-use
      --interop-num-validators=64
      --interop-start-index=$val_start_index
    volumes:
      - $data_dir_pos/node$i/consensus/validatordata:/root/.ethereum
      - $data_dir_pos/config.yml:/config/config.yml
    depends_on:
      consensus_node$i:
        condition: service_started
    networks:
      - skripsidchain
    restart: unless-stopped
EOF
        fi
    done

    generate_monitoring_stack "$compose_file"
    generate_footer "$compose_file"
}

# --- Main Execution Logic ---
log_step "COMPOSE FILE GENERATION for NETWORK_TYPE: $NETWORK_TYPE"

if [ "$NETWORK_TYPE" == "PoA" ]; then
    generate_poa_compose
elif [ "$NETWORK_TYPE" == "PoS" ]; then
    generate_pos_compose
else
    log_error "Invalid NETWORK_TYPE '$NETWORK_TYPE' in .env file."
fi
