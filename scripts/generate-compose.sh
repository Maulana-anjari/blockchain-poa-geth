#!/bin/bash
# File: scripts/generate-compose.sh
# Generates Docker Compose files for PoA or PoS networks.

set -e
source ./scripts/logger.sh
source ./config.sh

# --- Output File Definitions ---
POA_OUTPUT_FILE="docker-compose.poa.yml"
POS_OUTPUT_FILE="docker-compose.pos.yml"

# --- Reusable Service Snippets ---
generate_monitoring_stack() {
    local output_file=$1
    cat >> "$output_file" <<EOF

# --- Monitoring Stack ---
  ethstats-server:
    build:
      context: https://github.com/goerli/ethstats-server.git
    container_name: ethstats-server
    environment:
      WS_SECRET: "\${ETHSTATS_WS_SECRET}"
    ports:
      - "\${BASE_MONITORING_HTTP_PORT}:3000"
    networks:
      - skripsidchain
    restart: unless-stopped

  influxdb:
    image: influxdb:1.8
    container_name: influxdb
    volumes:
      - influxdb_data:/var/lib/influxdb
    environment:
      INFLUXDB_DB: "\${INFLUXDB_DB}"
      INFLUXDB_ADMIN_USER: "\${INFLUXDB_USER}"
      INFLUXDB_ADMIN_PASSWORD: "\${INFLUXDB_PASSWORD}"
      INFLUXDB_HTTP_AUTH_ENABLED: "true"
      INFLUXDB_USER: "\${INFLUXDB_USER}"
      INFLUXDB_USER_PASSWORD: "\${INFLUXDB_PASSWORD}"
    networks:
      - skripsidchain
    restart: unless-stopped

  grafana:
    image: grafana/grafana-oss:latest
    container_name: grafana
    depends_on: [influxdb]
    volumes:
      - grafana_data:/var/lib/grafana
    ports:
      - "\${BASE_GRAFANA_HTTP_PORT}:3000"
    environment:
      GF_SECURITY_ADMIN_USER: admin
      GF_SECURITY_ADMIN_PASSWORD: "\${GRAFANA_ADMIN_PASSWORD}"
    networks:
      - skripsidchain
    restart: unless-stopped
  
  prometheus:
    image: prom/prometheus:latest
    container_name: prometheus
    volumes:
      - ./monitoring/prometheus.yml:/etc/prometheus/prometheus.yml
    ports:
      - "9090:9090"
    networks:
      - skripsidchain
    restart: unless-stopped

  pushgateway:
    image: prom/pushgateway:latest
    container_name: pushgateway
    ports:
      - "9091:9091"
    networks:
      - skripsidchain
    restart: unless-stopped
EOF
}

generate_footer() {
    local output_file=$1
    cat >> "$output_file" <<EOF

# --- Network & Volume Definitions ---
networks:
  skripsidchain:
    external: true
    driver: bridge
    name: skripsidchain

volumes:
  grafana_data: {}
  influxdb_data: {}
EOF
}

# --- PoA Network Generation ---
generate_poa_compose() {
    log_action "Generating services for PoA network"
    cat > "$POA_OUTPUT_FILE" <<EOF
# Auto-generated by scripts/generate-compose.sh for a PoA network.
services:
EOF
    # --- Bootnode (Non-Signer 1) ---
    cat >> "$POA_OUTPUT_FILE" <<EOF
  # --- Bootnode (Non-Signer 1) ---
  nonsigner1:
    image: ${GETH_IMAGE_TAG_POA}
    container_name: nonsigner1
    hostname: nonsigner1
    volumes:
      - ./config/genesis.json:/config/genesis.json:ro
      - ./data/nonsigner1:/root/.ethereum
      - ./config/passwords/nonsigner1.pass:/root/password.txt:ro
      - ./data/nonsigner1/keystore:/root/.ethereum/keystore:ro
    ports:
      - "\${BASE_GETH_P2P_PORT}:\${BASE_GETH_P2P_PORT}/tcp"
      - "\${BASE_GETH_P2P_PORT}:\${BASE_GETH_P2P_PORT}/udp"
      - "\${BASE_GETH_HTTP_PORT}:8545"
      - "\${BASE_GETH_WS_PORT}:8546"
    command: >
      geth
      --nodekey /root/.ethereum/geth/nodekey
      --datadir /root/.ethereum --keystore /root/.ethereum/keystore
      --networkid "\${NETWORK_ID}" --syncmode full --gcmode archive
      --port \${BASE_GETH_P2P_PORT}
      --http --http.addr "0.0.0.0" --http.port 8545 --http.api "eth,net,web3,clique,admin,personal" --http.corsdomain "*" --http.vhosts "*"
      --ws --ws.addr "0.0.0.0" --ws.port 8546 --ws.api "eth,net,web3,clique,admin,personal" --ws.origins "*"
      --metrics --metrics.expensive --metrics.influxdb
      --metrics.influxdb.endpoint "http://influxdb:8086"
      --metrics.influxdb.database "\${INFLUXDB_DB}"
      --metrics.influxdb.username "\${INFLUXDB_USER}"
      --metrics.influxdb.password "\${INFLUXDB_PASSWORD}"
      --ethstats "nonsigner1:\${ETHSTATS_WS_SECRET}@ethstats-server:3000"
      --password /root/password.txt --allow-insecure-unlock
    networks:
      - skripsidchain
    restart: unless-stopped
EOF
    # --- Signer Nodes (Clef + Geth) ---
    for i in $(seq 1 $NUM_SIGNERS); do
        HTTP_PORT=$((BASE_GETH_HTTP_PORT + (i * 2) + 10))
        WS_PORT=$((HTTP_PORT + 1))
        P2P_PORT=$((BASE_GETH_P2P_PORT + i))
        cat >> "$POA_OUTPUT_FILE" <<EOF

  # --- Signer Node ${i} ---
  clef${i}:
    build:
      context: .
      dockerfile: Dockerfile.clef
    container_name: clef${i}
    hostname: clef${i}
    environment:
      - CLEF_MASTER_PASSWORD=${SIGNER_PASS_PREFIX}${i}
      - NETWORK_ID=${NETWORK_ID}
    volumes:
      - ./data/signer${i}/keystore:/root/.ethereum/keystore:ro
      - ./data/clef${i}:/root/.clef
      - ./config/rules.js:/root/rules.js:ro
    command: /usr/local/bin/start-clef.sh
    networks:
      - skripsidchain
    restart: unless-stopped

  signer${i}:
    image: ${GETH_IMAGE_TAG_POA}
    container_name: signer${i}
    hostname: signer${i}
    depends_on:
      clef${i}:
        condition: service_started
      nonsigner1:
        condition: service_started
    volumes:
      - ./config/genesis.json:/config/genesis.json:ro
      - ./data/signer${i}:/root/.ethereum
    ports:
      - "${HTTP_PORT}:8545"
      - "${WS_PORT}:8546"
    command: >
      geth 
        --datadir /root/.ethereum 
        --networkid ${NETWORK_ID} 
        --syncmode full 
        --port ${P2P_PORT} 
        --http --http.addr "0.0.0.0" --http.port 8545 --http.api "eth,net,web3,clique,admin" --http.corsdomain "*" --http.vhosts "*" 
        --ws --ws.addr "0.0.0.0" --ws.port 8546 --ws.api "eth,net,web3,clique,admin" --ws.origins "*" 
        --metrics --metrics.expensive --metrics.influxdb 
        --metrics.influxdb.endpoint "http://influxdb:8086" 
        --metrics.influxdb.database "\${INFLUXDB_DB}" 
        --metrics.influxdb.username "\${INFLUXDB_USER}" 
        --metrics.influxdb.password "\${INFLUXDB_PASSWORD}" 
        --ethstats "signer${i}:\${ETHSTATS_WS_SECRET}@ethstats-server:3000" 
        --bootnodes "\${BOOTNODE_ENODE}" 
        --signer "http://clef${i}:8550" 
        --mine --miner.etherbase "\${SIGNER${i}_ADDRESS}"
    networks:
      - skripsidchain
    restart: unless-stopped
EOF
    done
    # --- Other Non-Signer Nodes ---
    if [ $NUM_NONSIGNERS -gt 1 ]; then
        for i in $(seq 2 $NUM_NONSIGNERS); do
            HTTP_PORT=$((BASE_GETH_HTTP_PORT + (NUM_SIGNERS * 2) + (i * 2) + 20))
            WS_PORT=$((HTTP_PORT + 1))
            P2P_PORT=$((BASE_GETH_P2P_PORT + NUM_SIGNERS + i))
            cat >> "$POA_OUTPUT_FILE" <<EOF

  # --- Non-Signer Node ${i} ---
  nonsigner${i}:
    image: ${GETH_IMAGE_TAG_POA}
    container_name: nonsigner${i}
    hostname: nonsigner${i}
    depends_on:
      - nonsigner1
    volumes:
      - ./config/genesis.json:/config/genesis.json:ro
      - ./data/nonsigner${i}:/root/.ethereum
      - ./config/passwords/nonsigner${i}.pass:/root/password.txt:ro
    ports:
      - "${HTTP_PORT}:8545"
      - "${WS_PORT}:8546"
    command: >
      geth
      --datadir /root/.ethereum --keystore /root/.ethereum/keystore --networkid "\${NETWORK_ID}"
      --syncmode full --gcmode archive --port ${P2P_PORT}
      --http --http.addr "0.0.0.0" --http.port 8545 --http.api "eth,net,web3,clique,admin,personal" --http.corsdomain "*" --http.vhosts "*"
      --ws --ws.addr "0.0.0.0" --ws.port 8546 --ws.api "eth,net,web3,clique,admin,personal" --ws.origins "*"
      --metrics --metrics.expensive --metrics.influxdb
      --metrics.influxdb.endpoint "http://influxdb:8086"
      --metrics.influxdb.database "\${INFLUXDB_DB}"
      --metrics.influxdb.username "\${INFLUXDB_USER}"
      --metrics.influxdb.password "\${INFLUXDB_PASSWORD}"
      --ethstats "nonsigner${i}:\${ETHSTATS_WS_SECRET}@ethstats-server:3000"
      --password /root/password.txt --allow-insecure-unlock
      --bootnodes "\${BOOTNODE_ENODE}"
    networks:
      - skripsidchain
    restart: unless-stopped
EOF
        done
    fi
    generate_monitoring_stack "$POA_OUTPUT_FILE"
    generate_footer "$POA_OUTPUT_FILE"
    log_success "Finished generating docker-compose.poa.yml."
}

generate_pos_compose() {
    local compose_file="docker-compose.pos.yml"
    rm -f $compose_file
    log_info "Generating $compose_file for $POS_VALIDATOR_COUNT validators and $POS_NON_VALIDATOR_COUNT non-validators..."

    local total_nodes=$((POS_VALIDATOR_COUNT + POS_NON_VALIDATOR_COUNT))
    local min_sync_peers=0
    local data_dir_pos="./data/pos"

    echo "services:" > $compose_file

    for i in $(seq 1 $total_nodes); do
        local is_validator=false
        if [ $i -le $POS_VALIDATOR_COUNT ]; then
            is_validator=true
        fi
        local el_http_port=$((8545 + i - 1))
        local el_ws_port=$((8645 + i - 1))
        local el_p2p_port=$((30303 + i - 1))
        local cl_p2p_port=$((13000 + i - 1))
        local cl_grpc_port=$((4000 + i - 1))
        local cl_gateway_port=$((3500 + i - 1))

        # --- Geth (Execution Node) ---
        local geth_bootnode_param=""
        if [ $i -gt 1 ]; then
            geth_bootnode_param="--bootnodes=\${BOOTNODE_EL_ENODE}"
        fi

        cat >> "$compose_file" <<EOF
  execution_node$i:
    image: ${GETH_IMAGE_TAG_POS}
    container_name: execution_node$i
    hostname: execution_node$i
    command: >
      geth
      --nodekey /data/geth/nodekey --datadir=/data --keystore=/data/keystore
      --networkid=\${NETWORK_ID} --http --http.addr=0.0.0.0 --http.api=admin,debug,engine,eth,miner,net,rpc,txpool,web3
      --http.corsdomain=* --http.port=8545 --http.vhosts=* --ws --ws.api=eth,net,web3,engine,admin --ws.addr=0.0.0.0
      --ws.port=8546 --ws.origins=* --authrpc.vhosts=* --authrpc.addr=0.0.0.0 --authrpc.port=8551
      --authrpc.jwtsecret=/jwtsecret ${geth_bootnode_param} --port=30303 --allow-insecure-unlock
      --unlock=\${NODE${i}_ADDRESS} --password=/password.txt --syncmode=full
      --metrics --metrics.addr=0.0.0.0 --metrics.port=6060 --metrics.expensive
      --metrics.influxdb --metrics.influxdb.endpoint="http://influxdb:8086"
      --metrics.influxdb.database="\${INFLUXDB_DB}" --metrics.influxdb.username="\${INFLUXDB_USER}" --metrics.influxdb.password="\${INFLUXDB_PASSWORD}"
      --ethstats="execution_node$i:\${ETHSTATS_WS_SECRET}@ethstats-server:3000"
    volumes:
      - ${data_dir_pos}/node${i}/execution:/data
      - ${data_dir_pos}/jwtsecret:/jwtsecret
      - ${data_dir_pos}/password.pass:/password.txt
    ports:
      - "${el_http_port}:8545"
      - "${el_ws_port}:8546"
      - "${el_p2p_port}:30303"
      - "${el_p2p_port}:30303/udp"
    networks:
      - skripsidchain
    restart: unless-stopped
EOF
        if [ $i -gt 1 ]; then
            cat >> "$compose_file" <<EOF
    depends_on:
      - execution_node1
EOF
        fi

        # --- Prysm (Consensus Node) ---
        local prysm_peer_param=""
        if [ $i -gt 1 ]; then
            prysm_peer_param="--bootstrap-node=\${BOOTSTRAP_CL_ENR}"
        fi

        cat >> "$compose_file" <<EOF
  consensus_node$i:
    image: ${CONSENSUS_CLIENT_IMAGE}
    container_name: consensus_node$i
    hostname: consensus_node$i
    command: >
      --datadir=/prysm/consensus/beacondata --chain-config-file=/prysm/config.yml --genesis-state=/prysm/genesis.ssz
      ${prysm_peer_param} --min-sync-peers=${min_sync_peers} --p2p-static-id=true
      --contract-deployment-block=0 --chain-id=\${NETWORK_ID} --execution-endpoint=http://execution_node${i}:8551
      --suggested-fee-recipient=\${NODE${i}_ADDRESS} --enable-debug-rpc-endpoints --minimum-peers-per-subnet=0
      --jwt-secret=/prysm/jwtsecret --accept-terms-of-use --rpc-host=0.0.0.0 --grpc-gateway-host=0.0.0.0
      --p2p-tcp-port=${cl_p2p_port} --p2p-udp-port=${cl_p2p_port} --rpc-port=4000 --grpc-gateway-port=3500 --interop-eth1data-votes
    volumes:
      - ${data_dir_pos}/node${i}/consensus:/prysm/consensus
      - ${data_dir_pos}/config.yml:/prysm/config.yml
      - ${data_dir_pos}/genesis.ssz:/prysm/genesis.ssz
      - ${data_dir_pos}/jwtsecret:/prysm/jwtsecret
    ports:
      - "${cl_p2p_port}:${cl_p2p_port}"
      - "${cl_p2p_port}:${cl_p2p_port}/udp"
      - "${cl_grpc_port}:4000"
      - "${cl_gateway_port}:3500"
    networks:
      - skripsidchain
    restart: unless-stopped
    depends_on:
      - execution_node$i
EOF
        if [ $i -gt 1 ]; then
            cat >> "$compose_file" <<EOF
      - consensus_node1
EOF
        fi

        # --- Prysm (Validator) ---
        if $is_validator; then
            local num_validators_per_node=$((64 / POS_VALIDATOR_COUNT))
            local val_start_index=$(((i - 1) * num_validators_per_node))
            cat >> "$compose_file" <<EOF
  validator_node$i:
    image: ${CONSENSUS_CLIENT_VALIDATOR_IMAGE}
    container_name: validator_node$i
    hostname: validator_node$i
    command: >
      --datadir=/prysm/consensus/validatordata --beacon-rpc-provider=consensus_node${i}:4000
      --chain-config-file=/prysm/config.yml --accept-terms-of-use
      --interop-num-validators=${num_validators_per_node} --interop-start-index=${val_start_index}
    volumes:
      - ${data_dir_pos}/node${i}/consensus:/prysm/consensus
      - ${data_dir_pos}/config.yml:/prysm/config.yml
    depends_on:
      - consensus_node$i
    networks:
      - skripsidchain
    restart: unless-stopped
EOF
        fi
    done

    generate_monitoring_stack "$compose_file"
    generate_footer "$compose_file"
    log_success "Finished generating docker-compose.pos.yml."
}

# --- Main Execution Logic ---
log_step "COMPOSE FILE GENERATION for NETWORK_TYPE: $NETWORK_TYPE"

if [ "$NETWORK_TYPE" == "PoA" ]; then
    generate_poa_compose
elif [ "$NETWORK_TYPE" == "PoS" ]; then
    generate_pos_compose
else
    log_error "Invalid NETWORK_TYPE '$NETWORK_TYPE' in .env file."
fi
